<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AI Memory Service — Качество и Метрики</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; background:#0b0e14; color: #e5e7eb; }
    header { padding: 16px 24px; background: #111827; border-bottom: 1px solid #1f2937; }
    h1 { margin: 0; font-size: 20px; }
    main { padding: 16px 24px; display: grid; grid-template-columns: 1fr; gap: 16px; }
    section { background: #0f172a; border: 1px solid #1f2937; border-radius: 8px; padding: 16px; }
    h2 { margin: 0 0 8px 0; font-size: 16px; color:#cbd5e1; }
    .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 12px; }
    .card { background:#0b1220; border:1px solid #1f2937; border-radius:8px; padding:12px; }
    .kpi { font-size: 28px; font-weight: 600; color: #e2e8f0; }
    .label { font-size: 12px; color:#94a3b8; }
    canvas { width: 100%; height: 160px; display:block; background:#0b1220; border-radius:6px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 8px; border-bottom: 1px solid #1f2937; text-align:left; font-size: 13px; }
    th { color:#93c5fd; }
    .muted { color:#94a3b8; }
    .ok { color:#10b981; }
    .warn { color:#f59e0b; }
    .bad { color:#ef4444; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .row { display:flex; gap:12px; align-items:center; }
    .pill { padding:2px 8px; border-radius:999px; background:#111827; border:1px solid #1f2937; font-size:12px; }
    a { color:#60a5fa; text-decoration:none; }
  </style>
</head>
<body>
<header>
  <h1>AI Memory Service — Дашборд качества и метрик</h1>
  <div class="muted">Обновляется каждые 5 секунд. Источники: /reports/*.json(l), /metrics, /health</div>
</header>
<main>
  <section>
    <h2>Сводные классические метрики ранжирования</h2>
    <div class="grid">
      <div class="card"><div class="label">Precision@K</div><div id="kpi_p_at_k" class="kpi">—</div></div>
      <div class="card"><div class="label">Recall@K</div><div id="kpi_r_at_k" class="kpi">—</div></div>
      <div class="card"><div class="label">MRR</div><div id="kpi_mrr" class="kpi">—</div></div>
      <div class="card"><div class="label">nDCG</div><div id="kpi_ndcg" class="kpi">—</div></div>
    </div>
    <div class="grid" style="margin-top:12px">
      <div class="card">
        <div class="label">Динамика качества (Precision@K / Recall@K / nDCG)</div>
        <canvas id="chart_quality"></canvas>
      </div>
      <div class="card">
        <div class="label">Время инференса эмбеддингов (сек)</div>
        <canvas id="chart_infer"></canvas>
      </div>
    </div>
  </section>

  <section>
    <h2>Продвинутые метрики</h2>
    <div class="grid">
      <div class="card">
        <div class="label">Кривая удержания (retention curve)</div>
        <canvas id="chart_retention"></canvas>
      </div>
      <div class="card">
        <div class="label">Reasoning (Depth2/Depth3 Success)</div>
        <canvas id="chart_depth"></canvas>
      </div>
      <div class="card">
        <div class="label">Connection Quality</div>
        <canvas id="chart_conn"></canvas>
      </div>
      <div class="card">
        <div class="label">Retention AUC (тренд)</div>
        <canvas id="chart_auc"></canvas>
      </div>
    </div>
  </section>

  <section>
    <h2>Граф‑ориентированные и человеко‑подобные метрики</h2>
    <table>
      <thead>
        <tr>
          <th>Метрика</th><th>Значение</th><th>Источник</th><th>Комментарий</th>
        </tr>
      </thead>
      <tbody id="table_advanced">
        <!-- Заполняется из JS -->
      </tbody>
    </table>
    <div class="muted" style="margin-top:8px">Метрики помеченные N/A рассчитываются по расширенному протоколу; интеграция готова, данные будут подхватываться при их появлении в /reports/*</div>
  </section>

  <section>
    <h2>Состояние сервисов</h2>
    <div class="grid">
      <div class="card"><div class="label">Embedding Server</div><div id="svc_emb" class="kpi">—</div></div>
      <div class="card"><div class="label">Embedding Dimension</div><div id="emb_dim" class="kpi">—</div></div>
      <div class="card"><div class="label">Avg Inference Time (s)</div><div id="avg_inf" class="kpi">—</div></div>
      <div class="card"><div class="label">Cache Hit Rate</div><div id="hit_rate" class="kpi">—</div></div>
    </div>
  </section>
</main>

<script>
const sleep = (ms) => new Promise(r => setTimeout(r, ms));
const PARAMS = new URLSearchParams(location.search);
const API_BASE = PARAMS.get('api') || 'http://127.0.0.1:8080';

async function fetchText(url){
  try{ const r = await fetch(url, {cache:'no-store'}); if(!r.ok) return null; return await r.text(); }catch(e){ return null; }
}
async function fetchJSON(url){
  try{ const r = await fetch(url, {cache:'no-store'}); if(!r.ok) return null; return await r.json(); }catch(e){ return null; }
}
function parseJSONL(text){ if(!text) return []; return text.trim().split(/\n+/).map(l=>{ try{return JSON.parse(l);}catch(_){return null}}).filter(Boolean); }

function fmt(x){ if(x==null) return '—'; return (Math.round(x*1000)/1000).toFixed(3); }

// Simple line chart renderer (no deps)
function drawLineChart(canvas, series){
  const ctx = canvas.getContext('2d');
  const W = canvas.clientWidth, H = canvas.clientHeight;
  canvas.width = W * devicePixelRatio; canvas.height = H * devicePixelRatio; ctx.scale(devicePixelRatio, devicePixelRatio);
  ctx.clearRect(0,0,W,H); ctx.fillStyle='#0b1220'; ctx.fillRect(0,0,W,H);
  const colors = ['#60a5fa','#fbbf24','#34d399','#f472b6','#a78bfa'];
  const allY = series.flatMap(s=>s.data.map(v=>v==null?0:v));
  const minY = Math.min(0, ...allY), maxY = Math.max(1, ...allY);
  const pad=12; const plotW=W-2*pad, plotH=H-2*pad;
  ctx.strokeStyle='#1f2937'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(pad, pad+plotH); ctx.lineTo(pad+plotW, pad+plotH); ctx.stroke();
  series.forEach((s,idx)=>{
    ctx.strokeStyle = colors[idx%colors.length]; ctx.lineWidth=2; ctx.beginPath();
    s.data.forEach((y,i)=>{
      const x = pad + (i/(Math.max(1,s.data.length-1)))*plotW;
      const yy = pad + plotH - ((y-minY)/(maxY-minY||1))*plotH;
      if(i===0) ctx.moveTo(x,yy); else ctx.lineTo(x,yy);
    });
    ctx.stroke();
  });
}

// Live series cached in browser
const Q_P = []; const Q_R = []; const Q_N = []; const INF_T = [];
const DEPTH2 = []; const DEPTH3 = []; const CONNQ = []; const RETAUC = [];
const MAX_POINTS = 100;

async function computeLiveQuality(base){
  const cats = {
    'rust': [
      'What are Rust unique features for memory safety?',
      'Which tool manages Rust dependencies?'
    ],
    'python': [
      'How to manage Python packages?',
      'What library helps with dataframes in Python?'
    ],
    'cooking': [
      'How to cook spaghetti properly?',
      'What gives bread a crispy crust?'
    ],
    'travel': [
      'Advice for trains in Japan?',
      'How to travel light on flights?'
    ],
    'ml': [
      'How to prevent overfitting?',
      'What method adjusts step size in optimization?'
    ],
  };
  const k = 5;
  const metrics = [];
  for(const [cat, queries] of Object.entries(cats)){
    for(const q of queries){
      try{
        const resp = await fetch(API_BASE + '/search', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({query:q, limit: Math.max(10,k)})});
        if(!resp.ok) continue;
        const data = await resp.json();
        const items = data.results || [];
        const retrieved = items.slice(0,k);
        const relevant = new Set(items.filter(m => String(m.context_path||'').startsWith('quality/'+cat)).map(m => m.id));
        // compute p@k, r@k, ndcg
        let hits=0, rels=Array(k).fill(0);
        for(let i=0;i<k;i++){
          if(i<retrieved.length && relevant.has(retrieved[i].id)){ hits++; rels[i]=1;}
        }
        const p_at_k = hits/Math.max(1,k);
        const r_at_k = hits/Math.max(1,relevant.size);
        // nDCG approx via bit_length analog
        let dcg=0, idcg=0; for(let i=1;i<=k;i++){ if(rels[i-1]) dcg += 1/(1+Math.clz32(i)); }
        const idealHits = Math.min(k, relevant.size); for(let i=1;i<=idealHits;i++){ idcg += 1/(1+Math.clz32(i)); }
        const ndcg = idcg>0 ? dcg/idcg : 0;
        metrics.push({p_at_k, r_at_k, ndcg});
      }catch(e){/* ignore */}
    }
  }
  if(metrics.length>0){
    const avg = (arr, key) => arr.reduce((a,b)=>a+(b[key]||0),0)/arr.length;
    return {p_at_k: avg(metrics,'p_at_k'), r_at_k: avg(metrics,'r_at_k'), ndcg: avg(metrics,'ndcg')};
  }
  return null;
}

async function update(){
  // Load quality (prefer stream, fallback to single report)
  const stream = parseJSONL(await fetchText('/reports/quality_stream.jsonl'));
  const last = stream.at(-1);
  let p_at_k, r_at_k, mrr, ndcg;
  if(last && last.aggregate){ ({p_at_k, r_at_k, mrr, ndcg} = last.aggregate); }
  else {
    const rep = await fetchJSON('/reports/quality_report.json');
    if(rep && rep.aggregate){ ({p_at_k, r_at_k, mrr, ndcg} = rep.aggregate); }
    else {
      // As a fallback, compute live quality via API
      const live = await computeLiveQuality('/');
      if(live){ ({p_at_k, r_at_k, ndcg} = live); mrr = null; }
    }
  }
  document.getElementById('kpi_p_at_k').textContent = fmt(p_at_k);
  document.getElementById('kpi_r_at_k').textContent = fmt(r_at_k);
  document.getElementById('kpi_mrr').textContent   = fmt(mrr);
  document.getElementById('kpi_ndcg').textContent  = fmt(ndcg);

  // Quality chart
  // Maintain local series when stream absent
  if(typeof p_at_k === 'number') Q_P.push(p_at_k);
  if(typeof r_at_k === 'number') Q_R.push(r_at_k);
  if(typeof ndcg === 'number')   Q_N.push(ndcg);
  while(Q_P.length>MAX_POINTS){ Q_P.shift(); Q_R.shift(); Q_N.shift(); }
  const seriesQ = [
    {name:'P@K', data: (stream.length? stream.map(x=>x.aggregate?.p_at_k ?? null) : Q_P)},
    {name:'R@K', data: (stream.length? stream.map(x=>x.aggregate?.r_at_k ?? null) : Q_R)},
    {name:'nDCG', data:(stream.length? stream.map(x=>x.aggregate?.ndcg ?? null) : Q_N)}
  ];
  drawLineChart(document.getElementById('chart_quality'), seriesQ);

  // Metrics/health
  const metrics_ts = parseJSONL(await fetchText('/reports/metrics_timeseries.jsonl'));
  const lastM = metrics_ts.at(-1) || {};
  const embOk = !!(lastM.embedding && lastM.embedding.healthy);
  const avgInf = lastM.embedding?.stats?.average_inference_time_sec;
  const hitRate = lastM.embedding?.stats?.cache_hit_rate;
  const h = await fetchJSON(API_BASE + '/health');
  // Fallback to embedding /stats if metrics_ts missing
  let embStats = null; if(!lastM.embedding){ embStats = await fetchJSON(API_BASE + '/stats').catch(()=>null); }
  const fim = embOk ? avgInf : (embStats?.embedding?.average_inference_time_sec ?? null);
  const hr  = embOk ? hitRate : (embStats?.embedding?.cache_hit_rate ?? null);
  document.getElementById('svc_emb').textContent = embOk ? 'OK' : 'DOWN';
  document.getElementById('svc_emb').className   = 'kpi ' + (embOk?'ok':'bad');
  document.getElementById('emb_dim').textContent = h?.embedding_dimension ?? '—';
  document.getElementById('avg_inf').textContent = fmt(fim);
  document.getElementById('hit_rate').textContent = fmt(hr);

  if(typeof fim === 'number'){ INF_T.push(fim); while(INF_T.length>MAX_POINTS) INF_T.shift(); }
  drawLineChart(document.getElementById('chart_infer'), [ {name:'t', data: (metrics_ts.length? metrics_ts.map(x=>x.embedding?.stats?.average_inference_time_sec ?? null) : INF_T)} ]);

  // Advanced table: fill known metrics + placeholders
  const tbody = document.getElementById('table_advanced');
  tbody.innerHTML = '';
  const addRow = (name, val, src, comment) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${name}</td><td class="mono">${val}</td><td class="muted">${src}</td><td class="muted">${comment}</td>`;
    tbody.appendChild(tr);
  };
  // Classic
  addRow('Hits@K / Precision@K', fmt(p_at_k), 'quality_stream / report', 'Доля релевантов в топ‑K');
  addRow('Recall@K', fmt(r_at_k), 'quality_stream / report', 'Доля найденных релевантов среди всех релевантов');
  addRow('MRR', fmt(mrr), 'quality_stream / report', 'Средняя обратная позиция первого релеванта');
  addRow('nDCG', fmt(ndcg), 'quality_stream / report', 'Качество ранжирования с учётом позиции');
  // Extended metrics (from last.extended if present)
  const ext = last?.extended || {};
  addRow('Stratified Hits@K', fmt(ext.stratified_p_at_k ?? null), 'extended', 'Взвешено по частотности сущн/связей');
  addRow('Stratified MRR', fmt(ext.stratified_mrr ?? null), 'extended', 'Компенсация популярности/редкости');
  addRow('Consistency (консистентность знаний)', fmt(ext.consistency_jaccard_at_k ?? null), 'extended', 'Стабильность извлечения при варьировании запроса и времени');
  const g = ext.graph || {};
  addRow('Connection Quality (качество ассоциаций)', fmt(ext.connection_quality ?? g.two_hop_expansion ?? null), 'extended/graph', 'Expansiveness/двух‑хоповое расширение');
  addRow('Memory Persistence (долговременность)', fmt(ext.memory_retention ?? null), 'extended', 'Сохранность знаний over‑time');
  addRow('Reasoning Depth (глубина рассуждений)', fmt(ext.reasoning_depth ?? null), 'extended', 'Многошаговые выводы');
  addRow('Depth2 Success', fmt(ext.depth2_success ?? null), 'extended', 'Доля запросов с приростом nDCG ≥ 0.1');
  addRow('Depth3 Success', fmt(ext.depth3_success ?? null), 'extended', 'Доля запросов с приростом nDCG ≥ 0.2');
  addRow('Coverage Ratio (покрытие графа)', fmt(ext.coverage_ratio ?? null), 'extended', 'Доля покрытых сущностей/отношений');
  addRow('Diversity Score (разнообразие выдачи)', fmt(ext.diversity_entropy ?? null), 'extended', 'Энтропия контекстов/результатов');
  addRow('Contextual Adaptation Score', fmt(ext.contextual_gain_ndcg ?? null), 'extended', 'Выигрыш от контекста в nDCG');
  addRow('Human-likeness Evaluation', fmt(ext.human_likeness_score ?? null), 'extended', 'Human Eval (субъективный)');
  addRow('Graph Connectivity/Expansion', fmt(g.two_hop_expansion ?? null), '/analytics/graph', 'Среднее двух‑хоповое расширение');
  addRow('Graph Avg Closure', fmt(g.avg_closure ?? null), '/analytics/graph', 'Средняя кластерность/triad closure');
  addRow('Graph Avg Shortest Path', fmt(g.avg_shortest_path ?? null), '/analytics/graph', 'Средняя длина кратч. пути');
  addRow('Connection Quality (composite)', fmt(ext.connection_quality ?? null), 'extended/graph', 'Сводная метрика связности');
  const ret = ext.memory_retention || {};
  addRow('Memory Retention (ratio)', fmt(ret.ratio ?? null), 'extended', 'post/baseline');
  addRow('Memory Retention AUC', fmt(ret.auc ?? null), 'extended', 'Средняя удерживаемость');

  // Time series for depth and connection quality
  if (typeof ext.depth2_success === 'number') { DEPTH2.push(ext.depth2_success); if (DEPTH2.length>MAX_POINTS) DEPTH2.shift(); }
  if (typeof ext.depth3_success === 'number') { DEPTH3.push(ext.depth3_success); if (DEPTH3.length>MAX_POINTS) DEPTH3.shift(); }
  if (typeof ext.connection_quality === 'number') { CONNQ.push(ext.connection_quality); if (CONNQ.length>MAX_POINTS) CONNQ.shift(); }
  drawLineChart(document.getElementById('chart_depth'), [
    {name:'Depth2', data: DEPTH2.length ? DEPTH2 : stream.map(x=>x.extended?.depth2_success ?? null)},
    {name:'Depth3', data: DEPTH3.length ? DEPTH3 : stream.map(x=>x.extended?.depth3_success ?? null)}
  ]);
  drawLineChart(document.getElementById('chart_conn'), [
    {name:'ConnQ', data: CONNQ.length ? CONNQ : stream.map(x=>x.extended?.connection_quality ?? null)}
  ]);

  // Retention AUC trend
  const aucSeries = stream.map(x=>x.extended?.memory_retention?.auc ?? null);
  if (typeof (last?.extended?.memory_retention?.auc) === 'number') {
    RETAUC.push(last.extended.memory_retention.auc);
    while (RETAUC.length>MAX_POINTS) RETAUC.shift();
  }
  drawLineChart(
    document.getElementById('chart_auc'),
    [ {name:'Retention AUC', data: aucSeries.filter(v=>v!=null).length ? aucSeries : RETAUC } ]
  );

  // Retention curve from last record
  const rc = ret.curve || [];
  if (rc.length) {
    const data = rc.map(p=>p.p_at_k);
    drawLineChart(document.getElementById('chart_retention'), [ {name:'retention', data} ]);
  }
  addRow('Evaluation under Label/Parameter Perturbation', fmt(ext.perturbation_robustness ?? null), 'extended', 'Устойчивость при вариации меток/параметров');
}

(async function loop(){
  while(true){
    await update();
    await sleep(5000);
  }
})();
</script>
</body>
</html>
